<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>PoseMatch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        margin: 0;
        font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: #0b0b0b;
        color: #e6e6e6;
      }
      header {
        padding: 14px 18px;
        border-bottom: 1px solid #1d1d1d;
      }
      main {
        padding: 14px 18px;
        display: grid;
        gap: 16px;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }
      .panel {
        background: #111;
        border: 1px solid #1e1e1e;
        border-radius: 12px;
        padding: 12px;
      }
      .panel h3 {
        margin: 0 0 8px;
        font-weight: 600;
      }
      canvas {
        width: 100%;
        height: auto;
        background: #141414;
        border-radius: 8px;
        display: block;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      button,
      label.btn {
        background: #222;
        border: 1px solid #333;
        color: #eee;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
      }
      button:hover,
      label.btn:hover {
        background: #2a2a2a;
      }
      input[type="file"] {
        display: none;
      }
      #status {
        opacity: 0.9;
      }
      .muted {
        color: #9aa0a6;
      }
      .ok {
        color: #6bd36b;
      }
      .warn {
        color: #f5c052;
      }
      .err {
        color: #ff6b6b;
      }
      .snapshots-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 12px;
        min-height: 120px;
      }
      .snapshot-item {
        position: relative;
        border-radius: 8px;
        overflow: hidden;
        background: #141414;
        border: 2px solid #333;
      }
      .snapshot-item img {
        width: 100%;
        height: auto;
        display: block;
      }
      .snapshot-info {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
        color: white;
        padding: 8px;
        font-size: 12px;
        text-align: center;
      }
      .snapshot-remove {
        position: absolute;
        top: 4px;
        right: 4px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        font-size: 12px;
      }
      .snapshot-remove:hover {
        background: rgba(255, 0, 0, 0.7);
      }
      .empty-state {
        grid-column: 1 / -1;
        text-align: center;
        padding: 40px 20px;
        color: #666;
        font-style: italic;
      }
      .clear-btn {
        margin-top: 12px;
        background: #444;
        border: 1px solid #555;
        color: #ccc;
      }
      .clear-btn:hover {
        background: #555;
      }
      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
        .snapshots-grid {
          grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h2>Pose Game</h2>
      <div class="muted">
        Webcam is mirrored for display only; backend always sees un-mirrored
        frames.
      </div>
    </header>

    <main>
      <div class="grid">
        <section class="panel">
          <h3>Live</h3>
          <canvas id="live" width="960" height="540"></canvas>
          <div class="row" style="margin-top: 8px">
            <button id="openCam">Open camera</button>
            <button id="setTarget">üì∏ Set target from webcam</button>
            <label class="btn">
              Upload target image‚Ä¶
              <input id="upload" type="file" accept="image/*" />
            </label>
            <button id="clearTarget">üßπ Clear target</button>
            <label class="row" style="gap: 6px">
              <input type="checkbox" id="multiperson" />
              <span>Multi-person mode</span>
            </label>
            <label class="row" style="margin-left: auto; gap: 6px">
              <input type="checkbox" id="mirror" checked />
              <span>Mirror webcam</span>
            </label>
          </div>
          <div id="status" class="muted" style="margin-top: 6px">
            Status: idle
          </div>
        </section>

        <section class="panel">
          <h3>Target</h3>
          <canvas id="target" width="960" height="540"></canvas>
          <div class="muted" style="margin-top: 6px">
            Webcam snapshots are mirrored for display, but uploads remain
            un-mirrored.
          </div>
        </section>
      </div>

      <section class="panel">
        <h3>Winning Snapshots</h3>
        <div class="muted" style="margin-bottom: 12px">
          Automatic captures when you achieve 90%+ accuracy
        </div>
        <div id="winningSnapshots" class="snapshots-grid">
          <div class="empty-state">
            üèÜ Achieve 90%+ accuracy to capture winning poses!
          </div>
        </div>
        <button id="clearSnapshots" class="clear-btn">
          üßπ Clear All Snapshots
        </button>
      </section>
    </main>

    <script>
      const API = "http://127.0.0.1:5000"; // Flask server

      const live = document.getElementById("live");
      const lctx = live.getContext("2d");
      const target = document.getElementById("target");
      const tctx = target.getContext("2d");

      const openBtn = document.getElementById("openCam");
      const setTargetBtn = document.getElementById("setTarget");
      const clearBtn = document.getElementById("clearTarget");
      const uploadInp = document.getElementById("upload");
      const mirrorEl = document.getElementById("mirror");
      const multipersonEl = document.getElementById("multiperson");
      const statusEl = document.getElementById("status");
      const winningSnapshotsEl = document.getElementById("winningSnapshots");
      const clearSnapshotsBtn = document.getElementById("clearSnapshots");

      // Hidden <video> and OFFSCREEN canvas (feed backend UN-MIRRORED frames)
      const video = document.createElement("video");
      video.playsInline = true;
      video.muted = true;
      video.autoplay = true;

      const work = document.createElement("canvas");
      work.width = live.width;
      work.height = live.height;
      const wctx = work.getContext("2d");

      let lastKp = null; // [{x,y}...], coords in live canvas space (single person)
      let lastAllKp = null; // [[[x,y}...], [[x,y]...], ...], coords for all people (multi-person)
      let lastKpScores = null; // [score...], accuracy scores (0-100) for each keypoint
      let lastAllScores = null; // [score...], overall scores for each person in multi-person mode
      let lastAllKpScores = null; // [[score...]...], keypoint scores for each person in multi-person mode
      let frameCount = 0;
      const sendEvery = 3; // throttle backend calls

      // Winning snapshots
      let winningSnapshots = [];
      let lastSnapshotTime = 0;
      const SNAPSHOT_COOLDOWN = 3000; // 3 seconds between snapshots
      const MAX_SNAPSHOTS = 12; // Maximum number of snapshots to keep

      // For uploaded target fit (so we can scale returned keypoints)
      let lastTargetFit = null; // { sx, sy, ox, oy } // scaleX/Y & offset

      // COCO pairs
      const SKELETON = [
        [5, 7],
        [7, 9],
        [6, 8],
        [8, 10],
        [11, 13],
        [13, 15],
        [12, 14],
        [14, 16],
        [5, 6],
        [11, 12],
        [5, 11],
        [6, 12],
      ];

      // Convert accuracy score (0-100) to color
      function scoreToColor(score) {
        if (score >= 70) {
          // Green for good match (70-100%)
          return "#00ff00";
        } else if (score >= 30) {
          // Yellow for close match (30-70%)
          return "#ffff00";
        } else {
          // Red for poor match (0-30%)
          return "#ff0000";
        }
      }

      function drawSkeleton(
        ctx,
        kp,
        color = "lime",
        radius = 3,
        kpScores = null
      ) {
        if (!kp || !kp.length) return;
        ctx.save();
        ctx.lineWidth = 2;

        // lines
        for (const [i, j] of SKELETON) {
          const a = kp[i],
            b = kp[j];
          if (!a || !b) continue;
          if (
            !Number.isFinite(a[0]) ||
            !Number.isFinite(a[1]) ||
            !Number.isFinite(b[0]) ||
            !Number.isFinite(b[1])
          )
            continue;

          // Use accuracy-based color for lines if scores available
          let lineColor = color;
          if (
            kpScores &&
            kpScores[i] !== undefined &&
            kpScores[j] !== undefined
          ) {
            // Use average accuracy of the two connected keypoints
            const avgScore = (kpScores[i] + kpScores[j]) / 2;
            lineColor = scoreToColor(avgScore);
          }

          ctx.strokeStyle = lineColor;
          ctx.beginPath();
          ctx.moveTo(a[0], a[1]);
          ctx.lineTo(b[0], b[1]);
          ctx.stroke();
        }

        // points
        for (let idx = 0; idx < kp.length; idx++) {
          const p = kp[idx];
          if (!p) continue;
          const [x, y] = p;
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

          // Use accuracy-based color for points if scores available
          let pointColor = color;
          if (kpScores && kpScores[idx] !== undefined) {
            pointColor = scoreToColor(kpScores[idx]);
          }

          ctx.fillStyle = pointColor;
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawMultipleSkeletons(ctx, allKp, allKpScores = null) {
        if (!allKp || !allKp.length) return;

        // Different colors for different people (used when no accuracy scores available)
        const colors = [
          "#00ff00", // lime
          "#ff6b6b", // red
          "#4ecdc4", // teal
          "#45b7d1", // blue
          "#96ceb4", // mint
          "#feca57", // yellow
          "#ff9ff3", // pink
          "#a8e6cf", // light green
          "#dda0dd", // plum
          "#98d8c8", // mint blue
        ];

        allKp.forEach((personKp, index) => {
          const color = colors[index % colors.length];
          const personKpScores =
            allKpScores && allKpScores[index] ? allKpScores[index] : null;
          drawSkeleton(ctx, personKp, color, 3, personKpScores);
        });
      }

      async function postFrame(url, blob, mirror = false) {
        const fd = new FormData();
        fd.append("frame", blob, "frame.jpg");
        fd.append("mirror", String(mirror));
        const resp = await fetch(url, { method: "POST", body: fd });
        if (!resp.ok) throw new Error(resp.statusText);
        return resp.json();
      }

      async function postImage(url, file) {
        const fd = new FormData();
        fd.append("image", file, file.name || "image.jpg");
        const resp = await fetch(url, { method: "POST", body: fd });
        if (!resp.ok) throw new Error(resp.statusText);
        return resp.json();
      }

      // Capture a winning snapshot
      function captureWinningSnapshot() {
        const now = Date.now();
        if (now - lastSnapshotTime < SNAPSHOT_COOLDOWN) {
          return; // Too soon since last snapshot
        }
        lastSnapshotTime = now;

        // Create a canvas to capture the current live view
        const captureCanvas = document.createElement("canvas");
        captureCanvas.width = live.width;
        captureCanvas.height = live.height;
        const captureCtx = captureCanvas.getContext("2d");

        // Draw the current live view
        captureCtx.clearRect(0, 0, captureCanvas.width, captureCanvas.height);
        captureCtx.save();
        if (mirrorEl.checked) {
          captureCtx.translate(captureCanvas.width, 0);
          captureCtx.scale(-1, 1);
        }
        captureCtx.drawImage(
          video,
          0,
          0,
          captureCanvas.width,
          captureCanvas.height
        );

        // Draw the skeleton overlay
        if (multipersonEl.checked && lastAllKp) {
          drawMultipleSkeletons(captureCtx, lastAllKp, lastAllKpScores);
        } else if (lastKp) {
          drawSkeleton(captureCtx, lastKp, "lime", 3, lastKpScores);
        }
        captureCtx.restore();

        // Convert to data URL
        const dataURL = captureCanvas.toDataURL("image/jpeg", 0.8);

        // Add to snapshots array
        const snapshot = {
          id: Date.now(),
          dataURL: dataURL,
          timestamp: new Date().toLocaleTimeString(),
          score: Math.round(getLastScore()),
        };

        winningSnapshots.unshift(snapshot); // Add to beginning

        // Remove old snapshots if we exceed max
        if (winningSnapshots.length > MAX_SNAPSHOTS) {
          winningSnapshots = winningSnapshots.slice(0, MAX_SNAPSHOTS);
        }

        updateSnapshotsDisplay();
      }

      function getLastScore() {
        // Extract the last score from the status text
        const statusText = statusEl.textContent;
        // Try multi-person format first
        let scoreMatch = statusText.match(/Best score: ([\d.]+)%/);
        if (!scoreMatch) {
          // Try single-person format
          scoreMatch = statusText.match(/Score: ([\d.]+)%/);
        }
        return scoreMatch ? parseFloat(scoreMatch[1]) : 90;
      }

      function updateSnapshotsDisplay() {
        if (winningSnapshots.length === 0) {
          winningSnapshotsEl.innerHTML = `
            <div class="empty-state">
              üèÜ Achieve 90%+ accuracy to capture winning poses!
            </div>
          `;
          return;
        }

        winningSnapshotsEl.innerHTML = winningSnapshots
          .map(
            (snapshot) => `
          <div class="snapshot-item">
            <img src="${snapshot.dataURL}" alt="Winning pose ${snapshot.score}%">
            <div class="snapshot-info">
              ${snapshot.score}% ‚Ä¢ ${snapshot.timestamp}
            </div>
            <button class="snapshot-remove" onclick="removeSnapshot(${snapshot.id})">√ó</button>
          </div>
        `
          )
          .join("");
      }

      function removeSnapshot(id) {
        winningSnapshots = winningSnapshots.filter((s) => s.id !== id);
        updateSnapshotsDisplay();
      }

      function clearAllSnapshots() {
        winningSnapshots = [];
        updateSnapshotsDisplay();
      }

      // Draw an ImageBitmap to canvas preserving aspect, return fit params
      function drawImageFit(ctx, img, canvas) {
        const W = canvas.width,
          H = canvas.height;
        const iw = img.width,
          ih = img.height;
        ctx.clearRect(0, 0, W, H);
        const s = Math.min(W / iw, H / ih);
        const dw = iw * s,
          dh = ih * s;
        const ox = (W - dw) / 2;
        const oy = (H - dh) / 2;
        ctx.drawImage(img, ox, oy, dw, dh);
        return { sx: s, sy: s, ox, oy };
      }

      // Draw an ImageBitmap to canvas preserving aspect, with horizontal flip, return fit params
      function drawImageFitFlipped(ctx, img, canvas) {
        const W = canvas.width,
          H = canvas.height;
        const iw = img.width,
          ih = img.height;
        ctx.clearRect(0, 0, W, H);
        const s = Math.min(W / iw, H / ih);
        const dw = iw * s,
          dh = ih * s;
        const ox = (W - dw) / 2;
        const oy = (H - dh) / 2;

        // Apply horizontal flip
        ctx.save();
        ctx.translate(ox + dw, oy);
        ctx.scale(-1, 1);
        ctx.drawImage(img, 0, 0, dw, dh);
        ctx.restore();

        return { sx: s, sy: s, ox, oy, flipped: true };
      }

      // MAIN LOOP
      async function loop() {
        requestAnimationFrame(loop);
        if (video.readyState < 2) return;

        const W = live.width,
          H = live.height;

        // ---- DISPLAY ----
        lctx.clearRect(0, 0, W, H);
        lctx.save();
        if (mirrorEl.checked) {
          lctx.translate(W, 0);
          lctx.scale(-1, 1);
        }
        lctx.drawImage(video, 0, 0, W, H);

        // Draw skeletons based on mode
        if (multipersonEl.checked) {
          drawMultipleSkeletons(lctx, lastAllKp, lastAllKpScores);
        } else {
          drawSkeleton(lctx, lastKp, "lime", 3, lastKpScores);
        }

        lctx.restore();

        // ---- BACKEND ----
        frameCount++;
        if (frameCount % sendEvery !== 0) return;

        wctx.clearRect(0, 0, W, H);
        wctx.drawImage(video, 0, 0, W, H);
        work.toBlob(
          async (blob) => {
            try {
              if (multipersonEl.checked) {
                // Multi-person mode
                const data = await postFrame(
                  `${API}/infer_multiperson`,
                  blob,
                  false
                );
                lastAllKp = data.all_keypoints || null;
                lastAllScores = data.all_scores || null;
                lastAllKpScores = data.all_keypoint_scores || null;
                lastKp = null; // Clear single person data
                lastKpScores = null; // Clear single person scores

                // Check for winning scores in multi-person mode
                if (lastAllScores) {
                  const maxScore = Math.max(
                    ...lastAllScores.filter((s) => s !== null)
                  );
                  if (maxScore >= 90) {
                    captureWinningSnapshot();
                  }
                }

                let msg = "No people detected.";
                if (data.all_keypoints && data.all_keypoints.length > 0) {
                  if (lastAllScores && lastAllScores.some((s) => s !== null)) {
                    const validScores = lastAllScores.filter((s) => s !== null);
                    const bestScore = Math.max(...validScores);
                    msg = `Tracking ${
                      data.num_people
                    } person(s). Best score: ${bestScore.toFixed(1)}%`;
                  } else {
                    msg = `Tracking ${data.num_people} person(s). Multi-person mode active.`;
                  }
                }
                statusEl.textContent = "Status: " + msg;
                statusEl.className =
                  data.all_keypoints && data.all_keypoints.length > 0
                    ? "ok"
                    : "muted";
              } else {
                // Single person mode (original behavior)
                const data = await postFrame(`${API}/infer`, blob, false);
                lastKp = data.keypoints || null;
                lastKpScores = data.keypoint_scores || null;
                lastAllKp = null; // Clear multi-person data

                // Check for winning score and capture snapshot
                if (data.score != null && data.score >= 90) {
                  captureWinningSnapshot();
                }

                // For testing: capture snapshot every 10 seconds if score > 80
                if (
                  data.score != null &&
                  data.score >= 80 &&
                  frameCount % 300 === 0
                ) {
                  console.log(
                    "Test snapshot captured at",
                    data.score.toFixed(1),
                    "%"
                  );
                  captureWinningSnapshot();
                }

                const msg =
                  data.score == null
                    ? data.keypoints
                      ? "Tracking‚Ä¶ set a target to start scoring."
                      : "No person detected."
                    : `Score: ${data.score.toFixed(1)}%`;
                statusEl.textContent = "Status: " + msg;
                statusEl.className = data.score != null ? "ok" : "muted";
              }
            } catch (e) {
              statusEl.textContent = "Status: backend error";
              statusEl.className = "err";
            }
          },
          "image/jpeg",
          0.7
        );
      }

      // -------- UI handlers --------
      openBtn.onclick = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: { ideal: 1280 }, height: { ideal: 720 } },
            audio: false,
          });
          video.srcObject = stream;
          video.play();
          requestAnimationFrame(loop);
          statusEl.textContent = "Status: camera opened";
          statusEl.className = "ok";
        } catch (e) {
          statusEl.textContent = "Status: failed to open camera";
          statusEl.className = "err";
        }
      };

      setTargetBtn.onclick = async () => {
        wctx.clearRect(0, 0, work.width, work.height);
        wctx.drawImage(video, 0, 0, work.width, work.height);
        work.toBlob(
          async (blob) => {
            try {
              const snap = await createImageBitmap(blob);
              // Use flipped drawing for webcam snapshots
              const fitParams = drawImageFitFlipped(tctx, snap, target);

              // Choose endpoint based on multi-person mode
              const endpoint = multipersonEl.checked
                ? `${API}/set_target_multiperson_frame`
                : `${API}/set_target_from_frame`;

              const data = await postFrame(endpoint, blob, false);

              if (data.ok) {
                const { sx, sy, ox, oy } = fitParams;

                if (multipersonEl.checked && data.all_keypoints) {
                  // Multi-person mode: draw all people with different colors
                  // Flip X coordinates for webcam snapshots since they're displayed flipped
                  const scaledKeypoints = data.all_keypoints.map((personKp) =>
                    personKp.map(([x, y]) => [
                      ox + (work.width - x) * sx, // Flip X coordinate
                      oy + y * sy,
                    ])
                  );
                  drawMultipleSkeletons(tctx, scaledKeypoints);
                  statusEl.textContent = `Status: Target set with ${data.num_people} person(s)!`;
                } else if (!multipersonEl.checked && data.keypoints) {
                  // Single-person mode: draw one skeleton
                  // Flip X coordinates for webcam snapshots since they're displayed flipped
                  const sk = data.keypoints.map(([x, y]) => [
                    ox + (work.width - x) * sx, // Flip X coordinate
                    oy + y * sy,
                  ]);
                  drawSkeleton(tctx, sk, "yellow");
                  statusEl.textContent = "Status: Target set!";
                } else {
                  statusEl.textContent =
                    "Status: " + (data.message || "No target set");
                  statusEl.className = "warn";
                  return;
                }

                statusEl.className = "ok";
              } else {
                statusEl.textContent =
                  "Status: " + (data.message || "Failed to set target");
                statusEl.className = "warn";
              }
            } catch (e) {
              statusEl.textContent = "Status: error setting target";
              statusEl.className = "err";
            }
          },
          "image/jpeg",
          0.8
        );
      };

      clearBtn.onclick = async () => {
        tctx.clearRect(0, 0, target.width, target.height);
        try {
          const r = await fetch(`${API}/clear_target`, { method: "POST" });
          await r.json();
        } catch {}
        statusEl.textContent = "Status: Target cleared.";
        statusEl.className = "muted";
      };

      uploadInp.onchange = async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;

        const img = await createImageBitmap(file);
        lastTargetFit = drawImageFit(tctx, img, target);

        try {
          // Choose endpoint based on multi-person mode
          const endpoint = multipersonEl.checked
            ? `${API}/set_target_multiperson_upload`
            : `${API}/set_target_from_upload`;

          const data = await postImage(endpoint, file);

          if (data.ok) {
            const { sx, sy, ox, oy } = lastTargetFit;

            if (multipersonEl.checked && data.all_keypoints) {
              // Multi-person mode: draw all people with different colors
              const scaledKeypoints = data.all_keypoints.map((personKp) =>
                personKp.map(([x, y]) => [ox + x * sx, oy + y * sy])
              );
              drawMultipleSkeletons(tctx, scaledKeypoints);
              statusEl.textContent = `Status: Target set from image with ${data.num_people} person(s)!`;
            } else if (!multipersonEl.checked && data.keypoints) {
              // Single-person mode: draw one skeleton
              const sk = data.keypoints.map(([x, y]) => [
                ox + x * sx,
                oy + y * sy,
              ]);
              drawSkeleton(tctx, sk, "yellow");
              statusEl.textContent = "Status: Target set from image!";
            } else {
              statusEl.textContent =
                "Status: " + (data.message || "No target set");
              statusEl.className = "warn";
              return;
            }

            statusEl.className = "ok";
          } else {
            statusEl.textContent =
              "Status: " + (data.message || "No person detected.");
            statusEl.className = "warn";
          }
        } catch (err) {
          statusEl.textContent = "Status: upload failed";
          statusEl.className = "err";
        } finally {
          uploadInp.value = "";
        }
      };

      clearSnapshotsBtn.onclick = () => {
        clearAllSnapshots();
      };
    </script>
  </body>
</html>
