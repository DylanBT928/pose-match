<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>PoseMatch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        margin: 0;
        font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: #0b0b0b;
        color: #e6e6e6;
      }
      header {
        padding: 14px 18px;
        border-bottom: 1px solid #1d1d1d;
      }
      main {
        padding: 14px 18px;
        display: grid;
        gap: 16px;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }
      .panel {
        background: #111;
        border: 1px solid #1e1e1e;
        border-radius: 12px;
        padding: 12px;
      }
      .panel h3 {
        margin: 0 0 8px;
        font-weight: 600;
      }
      canvas {
        width: 100%;
        height: auto;
        background: #141414;
        border-radius: 8px;
        display: block;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      button,
      label.btn {
        background: #222;
        border: 1px solid #333;
        color: #eee;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
      }
      button:hover,
      label.btn:hover {
        background: #2a2a2a;
      }
      input[type="file"] {
        display: none;
      }
      #status {
        opacity: 0.9;
      }
      .muted {
        color: #9aa0a6;
      }
      .ok {
        color: #6bd36b;
      }
      .warn {
        color: #f5c052;
      }
      .err {
        color: #ff6b6b;
      }
      .snapshots-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 12px;
        min-height: 120px;
      }
      .snapshot-item {
        position: relative;
        border-radius: 8px;
        overflow: hidden;
        background: #141414;
        border: 2px solid #333;
      }
      .snapshot-item img {
        width: 100%;
        height: auto;
        display: block;
      }
      .snapshot-info {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
        color: #fff;
        padding: 8px;
        font-size: 12px;
        text-align: center;
      }
      .snapshot-remove {
        position: absolute;
        top: 4px;
        right: 4px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        font-size: 12px;
      }
      .snapshot-remove:hover {
        background: rgba(255, 0, 0, 0.7);
      }
      .empty-state {
        grid-column: 1/-1;
        text-align: center;
        padding: 40px 20px;
        color: #666;
        font-style: italic;
      }
      .clear-btn {
        margin-top: 12px;
        background: #444;
        border: 1px solid #555;
        color: #ccc;
      }
      .clear-btn:hover {
        background: #555;
      }
      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
        .snapshots-grid {
          grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h2>Pose Game</h2>
      <div class="muted">
        Webcam is mirrored for display only; backend always sees un-mirrored
        frames.
      </div>
    </header>

    <main>
      <div class="grid">
        <section class="panel">
          <h3>Live</h3>
          <canvas id="live" width="960" height="540"></canvas>
          <div class="row" style="margin-top: 8px">
            <button id="openCam">Open camera</button>
            <button id="setTarget">üì∏ Set target from webcam</button>
            <label class="btn"
              >Upload target image‚Ä¶
              <input id="upload" type="file" accept="image/*"
            /></label>
            <button id="clearTarget">üßπ Clear target</button>
            <label class="row" style="gap: 6px"
              ><input type="checkbox" id="multiperson" /><span
                >Multi-person mode</span
              ></label
            >
            <label class="row" style="margin-left: auto; gap: 6px"
              ><input type="checkbox" id="mirror" checked /><span
                >Mirror webcam</span
              ></label
            >
          </div>
          <div id="status" class="muted" style="margin-top: 6px">
            Status: idle
          </div>
        </section>

        <section class="panel">
          <h3>Target</h3>
          <canvas id="target" width="960" height="540"></canvas>
          <div class="muted" style="margin-top: 6px">
            Webcam snapshots are mirrored for display, but uploads remain
            un-mirrored.
          </div>
        </section>
      </div>

      <section class="panel">
        <h3>Winning Snapshots</h3>
        <div class="muted" style="margin-bottom: 12px">
          Automatic captures when you achieve 90%+ accuracy
        </div>
        <div id="winningSnapshots" class="snapshots-grid">
          <div class="empty-state">
            üèÜ Achieve 90%+ accuracy to capture winning poses!
          </div>
        </div>
        <button id="clearSnapshots" class="clear-btn">
          üßπ Clear All Snapshots
        </button>
      </section>
    </main>

    <script>
      const API = "http://127.0.0.1:5000";

      const live = document.getElementById("live");
      const lctx = live.getContext("2d");
      const target = document.getElementById("target");
      const tctx = target.getContext("2d");

      const openBtn = document.getElementById("openCam");
      const setTargetBtn = document.getElementById("setTarget");
      const clearBtn = document.getElementById("clearTarget");
      const uploadInp = document.getElementById("upload");
      const mirrorEl = document.getElementById("mirror");
      const multipersonEl = document.getElementById("multiperson");
      const statusEl = document.getElementById("status");
      const winningSnapshotsEl = document.getElementById("winningSnapshots");
      const clearSnapshotsBtn = document.getElementById("clearSnapshots");

      const video = document.createElement("video");
      video.playsInline = true;
      video.muted = true;
      video.autoplay = true;

      const work = document.createElement("canvas");
      work.width = live.width;
      work.height = live.height;
      const wctx = work.getContext("2d");

      let lastKp = null,
        lastAllKp = null;
      let lastKpScores = null,
        lastAllScores = null,
        lastAllKpScores = null;
      let frameCount = 0;
      const sendEvery = 3;

      let winningSnapshots = [];
      let lastSnapshotTime = 0;
      const SNAPSHOT_COOLDOWN = 3000,
        MAX_SNAPSHOTS = 12;
      let lastTargetFit = null;

      const SKELETON = [
        [5, 7],
        [7, 9],
        [6, 8],
        [8, 10],
        [11, 13],
        [13, 15],
        [12, 14],
        [14, 16],
        [5, 6],
        [11, 12],
        [5, 11],
        [6, 12],
      ];

      function scoreToColor(score) {
        if (score >= 70) return "#00ff00";
        if (score >= 30) return "#ffff00";
        return "#ff0000";
      }
      function onScreen(x, y, W, H, pad = 0) {
        return x >= -pad && y >= -pad && x < W + pad && y < H + pad;
      }
      function looksInvalid(x, y, W, H) {
        const pad = 1;
        return (
          !Number.isFinite(x) ||
          !Number.isFinite(y) ||
          x <= pad ||
          y <= pad ||
          x >= W - pad ||
          y >= H - pad
        );
      }

      function drawSkeleton(
        ctx,
        kp,
        color = "lime",
        radius = 3,
        kpScores = null,
        hideOffscreen = true
      ) {
        if (!kp || !kp.length) return;
        const W = ctx.canvas.width,
          H = ctx.canvas.height;
        ctx.save();
        ctx.lineWidth = 2;
        for (const [i, j] of SKELETON) {
          const a = kp[i],
            b = kp[j];
          if (!a || !b) continue;
          const [ax, ay] = a,
            [bx, by] = b;
          if (![ax, ay, bx, by].every(Number.isFinite)) continue;
          if (
            hideOffscreen &&
            (looksInvalid(ax, ay, W, H) || looksInvalid(bx, by, W, H))
          )
            continue;
          let lineColor = color;
          if (
            kpScores &&
            kpScores[i] !== undefined &&
            kpScores[j] !== undefined
          ) {
            lineColor = scoreToColor((kpScores[i] + kpScores[j]) / 2);
          }
          ctx.strokeStyle = lineColor;
          ctx.beginPath();
          ctx.moveTo(ax, ay);
          ctx.lineTo(bx, by);
          ctx.stroke();
        }
        for (let idx = 0; idx < kp.length; idx++) {
          const p = kp[idx];
          if (!p) continue;
          const [x, y] = p;
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
          if (hideOffscreen && looksInvalid(x, y, W, H)) continue;
          let pointColor =
            kpScores && kpScores[idx] !== undefined
              ? scoreToColor(kpScores[idx])
              : color;
          ctx.fillStyle = pointColor;
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawMultipleSkeletons(ctx, allKp, allKpScores = null) {
        if (!allKp || !allKp.length) return;
        const colors = [
          "#00ff00",
          "#ff6b6b",
          "#4ecdc4",
          "#45b7d1",
          "#96ceb4",
          "#feca57",
          "#ff9ff3",
          "#a8e6cf",
          "#dda0dd",
          "#98d8c8",
        ];
        allKp.forEach((personKp, i) => {
          const color = colors[i % colors.length];
          const scores = allKpScores && allKpScores[i] ? allKpScores[i] : null;
          drawSkeleton(ctx, personKp, color, 3, scores, true);
        });
      }

      async function postFrame(url, blob, mirror = false) {
        const fd = new FormData();
        fd.append("frame", blob, "frame.jpg");
        fd.append("mirror", String(mirror));
        const r = await fetch(url, { method: "POST", body: fd });
        if (!r.ok) throw new Error(r.statusText);
        return r.json();
      }
      async function postImage(url, file) {
        const fd = new FormData();
        fd.append("image", file, file.name || "image.jpg");
        const r = await fetch(url, { method: "POST", body: fd });
        if (!r.ok) throw new Error(r.statusText);
        return r.json();
      }

      function captureWinningSnapshot() {
        const now = Date.now();
        if (now - lastSnapshotTime < SNAPSHOT_COOLDOWN) return;
        lastSnapshotTime = now;
        const c = document.createElement("canvas");
        c.width = live.width;
        c.height = live.height;
        const cx = c.getContext("2d");
        cx.clearRect(0, 0, c.width, c.height);
        cx.save();
        if (mirrorEl.checked) {
          cx.translate(c.width, 0);
          cx.scale(-1, 1);
        }
        cx.drawImage(video, 0, 0, c.width, c.height);
        if (multipersonEl.checked && lastAllKp)
          drawMultipleSkeletons(cx, lastAllKp, lastAllKpScores);
        else if (lastKp)
          drawSkeleton(cx, lastKp, "lime", 3, lastKpScores, true);
        cx.restore();
        const snapshot = {
          id: Date.now(),
          dataURL: c.toDataURL("image/jpeg", 0.8),
          timestamp: new Date().toLocaleTimeString(),
          score: Math.round(getLastScore()),
        };
        winningSnapshots.unshift(snapshot);
        if (winningSnapshots.length > MAX_SNAPSHOTS)
          winningSnapshots = winningSnapshots.slice(0, MAX_SNAPSHOTS);
        updateSnapshotsDisplay();
      }

      function getLastScore() {
        const text = statusEl.textContent || statusEl.innerHTML;
        const multi = text.match(/Person \d+: ([\d.]+)%/g);
        if (multi) {
          return Math.max(
            ...multi.map((m) =>
              m.match(/([\d.]+)%/) ? parseFloat(RegExp.$1) : 0
            )
          );
        }
        const one = text.match(/Score: ([\d.]+)%/);
        return one ? parseFloat(one[1]) : 90;
      }

      function updateSnapshotsDisplay() {
        if (winningSnapshots.length === 0) {
          winningSnapshotsEl.innerHTML = `<div class="empty-state">üèÜ Achieve 90%+ accuracy to capture winning poses!</div>`;
          return;
        }
        winningSnapshotsEl.innerHTML = winningSnapshots
          .map(
            (s) => `
          <div class="snapshot-item">
            <img src="${s.dataURL}" alt="Winning pose ${s.score}%">
            <div class="snapshot-info">${s.score}% ‚Ä¢ ${s.timestamp}</div>
            <button class="snapshot-remove" onclick="removeSnapshot(${s.id})">√ó</button>
          </div>`
          )
          .join("");
      }
      function removeSnapshot(id) {
        winningSnapshots = winningSnapshots.filter((s) => s.id !== id);
        updateSnapshotsDisplay();
      }
      function clearAllSnapshots() {
        winningSnapshots = [];
        updateSnapshotsDisplay();
      }

      function drawImageFit(ctx, img, canvas) {
        const W = canvas.width,
          H = canvas.height,
          iw = img.width,
          ih = img.height;
        ctx.clearRect(0, 0, W, H);
        const s = Math.min(W / iw, H / ih),
          dw = iw * s,
          dh = ih * s,
          ox = (W - dw) / 2,
          oy = (H - dh) / 2;
        ctx.drawImage(img, ox, oy, dw, dh);
        return { sx: s, sy: s, ox, oy };
      }
      function drawImageFitFlipped(ctx, img, canvas) {
        const W = canvas.width,
          H = canvas.height,
          iw = img.width,
          ih = img.height;
        ctx.clearRect(0, 0, W, H);
        const s = Math.min(W / iw, H / ih),
          dw = iw * s,
          dh = ih * s,
          ox = (W - dw) / 2,
          oy = (H - dh) / 2;
        ctx.save();
        ctx.translate(ox + dw, oy);
        ctx.scale(-1, 1);
        ctx.drawImage(img, 0, 0, dw, dh);
        ctx.restore();
        return { sx: s, sy: s, ox, oy, flipped: true };
      }

      async function loop() {
        requestAnimationFrame(loop);
        if (video.readyState < 2) return;
        const W = live.width,
          H = live.height;

        lctx.clearRect(0, 0, W, H);
        lctx.save();
        if (mirrorEl.checked) {
          lctx.translate(W, 0);
          lctx.scale(-1, 1);
        }
        lctx.drawImage(video, 0, 0, W, H);
        if (multipersonEl.checked)
          drawMultipleSkeletons(lctx, lastAllKp, lastAllKpScores);
        else drawSkeleton(lctx, lastKp, "lime", 3, lastKpScores, true);
        lctx.restore();

        frameCount++;
        if (frameCount % sendEvery !== 0) return;

        wctx.clearRect(0, 0, W, H);
        wctx.drawImage(video, 0, 0, W, H);
        work.toBlob(
          async (blob) => {
            try {
              if (multipersonEl.checked) {
                const data = await postFrame(
                  `${API}/infer_multiperson`,
                  blob,
                  false
                );
                lastAllKp = data.all_keypoints || null;
                lastAllScores = data.all_scores || null;
                lastAllKpScores = data.all_keypoint_scores || null;
                lastKp = null;
                lastKpScores = null;

                if (lastAllScores) {
                  const maxScore = Math.max(
                    ...lastAllScores.filter((s) => s !== null)
                  );
                  if (maxScore >= 90) captureWinningSnapshot();
                }

                let msg = "No people detected.";
                if (data.all_keypoints && data.all_keypoints.length > 0) {
                  if (lastAllScores && lastAllScores.some((s) => s !== null)) {
                    msg = `Tracking ${data.num_people} person(s)\n`;
                    lastAllScores.forEach((score, i) => {
                      msg +=
                        score != null
                          ? `Person ${i + 1}: ${score.toFixed(1)}%\n`
                          : `Person ${i + 1}: No target set\n`;
                    });
                    msg = msg.trim();
                  } else {
                    msg = `Tracking ${data.num_people} person(s). Multi-person mode active.`;
                  }
                }
                statusEl.innerHTML = "Status: " + msg.replace(/\n/g, "<br>");
                statusEl.className =
                  data.all_keypoints && data.all_keypoints.length > 0
                    ? "ok"
                    : "muted";
              } else {
                const data = await postFrame(`${API}/infer`, blob, false);
                lastKp = data.keypoints || null;
                lastKpScores = data.keypoint_scores || null;
                lastAllKp = null;

                if (data.score != null && data.score >= 90)
                  captureWinningSnapshot();
                if (
                  data.score != null &&
                  data.score >= 80 &&
                  frameCount % 300 === 0
                )
                  captureWinningSnapshot();

                const msg =
                  data.score == null
                    ? data.keypoints
                      ? "Tracking‚Ä¶ set a target to start scoring."
                      : "No person detected."
                    : `Score: ${data.score.toFixed(1)}%`;
                statusEl.textContent = "Status: " + msg;
                statusEl.className = data.score != null ? "ok" : "muted";
              }
            } catch (e) {
              statusEl.textContent = "Status: backend error";
              statusEl.className = "err";
            }
          },
          "image/jpeg",
          0.7
        );
      }

      openBtn.onclick = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: { ideal: 1280 }, height: { ideal: 720 } },
            audio: false,
          });
          video.srcObject = stream;
          video.play();
          requestAnimationFrame(loop);
          statusEl.textContent = "Status: camera opened";
          statusEl.className = "ok";
        } catch (e) {
          statusEl.textContent = "Status: failed to open camera";
          statusEl.className = "err";
        }
      };

      setTargetBtn.onclick = async () => {
        wctx.clearRect(0, 0, work.width, work.height);
        wctx.drawImage(video, 0, 0, work.width, work.height);
        work.toBlob(
          async (blob) => {
            try {
              const snap = await createImageBitmap(blob);
              const fitParams = drawImageFitFlipped(tctx, snap, target);
              const endpoint = multipersonEl.checked
                ? `${API}/set_target_multiperson_frame`
                : `${API}/set_target_from_frame`;
              const data = await postFrame(endpoint, blob, false);
              if (data.ok) {
                const { sx, sy, ox, oy } = fitParams;
                if (multipersonEl.checked && data.all_keypoints) {
                  const scaled = data.all_keypoints.map((person) =>
                    person.map((p) =>
                      p ? [ox + (work.width - p[0]) * sx, oy + p[1] * sy] : null
                    )
                  );
                  drawMultipleSkeletons(tctx, scaled, null);
                  statusEl.textContent = `Status: Target set with ${data.num_people} person(s)!`;
                } else if (!multipersonEl.checked && data.keypoints) {
                  const sk = data.keypoints.map((p) =>
                    p ? [ox + (work.width - p[0]) * sx, oy + p[1] * sy] : null
                  );
                  drawSkeleton(tctx, sk, "yellow", 3, null, true);
                  statusEl.textContent = "Status: Target set!";
                } else {
                  statusEl.textContent =
                    "Status: " + (data.message || "No target set");
                  statusEl.className = "warn";
                  return;
                }
                statusEl.className = "ok";
              } else {
                statusEl.textContent =
                  "Status: " + (data.message || "Failed to set target");
                statusEl.className = "warn";
              }
            } catch (e) {
              statusEl.textContent = "Status: error setting target";
              statusEl.className = "err";
            }
          },
          "image/jpeg",
          0.8
        );
      };

      clearBtn.onclick = async () => {
        tctx.clearRect(0, 0, target.width, target.height);
        try {
          const r = await fetch(`${API}/clear_target`, { method: "POST" });
          await r.json();
        } catch {}
        statusEl.textContent = "Status: Target cleared.";
        statusEl.className = "muted";
      };

      uploadInp.onchange = async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const img = await createImageBitmap(file);
        lastTargetFit = drawImageFit(tctx, img, target);
        try {
          const endpoint = multipersonEl.checked
            ? `${API}/set_target_multiperson_upload`
            : `${API}/set_target_from_upload`;
          const data = await postImage(endpoint, file);
          if (data.ok) {
            const { sx, sy, ox, oy } = lastTargetFit;
            if (multipersonEl.checked && data.all_keypoints) {
              const scaled = data.all_keypoints.map((person) =>
                person.map((p) => (p ? [ox + p[0] * sx, oy + p[1] * sy] : null))
              );
              drawMultipleSkeletons(tctx, scaled, null);
              statusEl.textContent = `Status: Target set from image with ${data.num_people} person(s)!`;
            } else if (!multipersonEl.checked && data.keypoints) {
              const sk = data.keypoints.map((p) =>
                p ? [ox + p[0] * sx, oy + p[1] * sy] : null
              );
              drawSkeleton(tctx, sk, "yellow", 3, null, true);
              statusEl.textContent = "Status: Target set from image!";
            } else {
              statusEl.textContent =
                "Status: " + (data.message || "No target set");
              statusEl.className = "warn";
              return;
            }
            statusEl.className = "ok";
          } else {
            statusEl.textContent =
              "Status: " + (data.message || "No person detected.");
            statusEl.className = "warn";
          }
        } catch (err) {
          statusEl.textContent = "Status: upload failed";
          statusEl.className = "err";
        } finally {
          uploadInp.value = "";
        }
      };

      clearSnapshotsBtn.onclick = () => {
        clearAllSnapshots();
      };
    </script>
  </body>
</html>
